\renewcommand{\A}{|[fill=black,text=white]|0}
\renewcommand{\B}{|[fill=black,text=ocre]|1}

\nsection{Roller-Board}

The puzzle {\it Roller-Board} consists of a $2D$ rectangular grid of
cells, each of which is labelled either `$0$' or `$1$':

\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\A&\A&\A&\A&\A\\
\A&\B&\A&\B&\A\\
\A&\A&\B&\A&\A\\
\A&\B&\A&\B&\A\\
\A&\A&\A&\A&\A\\
};
\end{tikzpicture}

\noindent The challenge is to roll one row or column at a time, so that the board is returned to its `correct' state:

\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\B&\B&\B\\
\A&\A&\A&\A&\A\\
\A&\A&\A&\A&\A\\
\A&\A&\A&\A&\A\\
\A&\A&\A&\A&\A\\
};
\end{tikzpicture}

having all $1s$ on the top row, and every other cell being a $0$.
Each `move' can be either:
\begin{itemize}
\item Roll a column one place up - i.e. the cells in this column all move up one, and the cell at the top `rolls around' and reappears at the bottom of this column.
\item Roll a column one place down - i.e. the cells in this column all move down one, and the cell at the bottom `rolls around' and reappears at the top of this column.
\item Roll a row one place left - i.e. the cells in this row all move left one, and the cell on the left `rolls around' and reappears on the right of this row.
\item Roll a row one place right - i.e. the cells in this row all right one, and the cell on the right `rolls around' and reappears on the left of this row.
\end{itemize}

To solve a $4 \times 4$ board:

\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\A&\A&\A\\
\A&\B&\A&\A\\
\A&\A&\B&\A\\
\A&\A&\A&\B\\
};
\end{tikzpicture}

the best solution might be:

Roll column 1 up~:
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt},baseline=(current bounding box.center)] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\B&\A\\
\A&\A&\A&\B\\
};
\end{tikzpicture}

Roll column 2 down~:
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt},baseline=(current bounding box.center)] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\B&\B\\
};
\end{tikzpicture}

Roll column 2 down~:
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt},baseline=(current bounding box.center)] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\B&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\B\\
};
\end{tikzpicture}

Roll column 3 down~:
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt},baseline=(current bounding box.center)] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\B&\B\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}



Here's another example of a board:

\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\A&\A&\A&\A\\
\B&\B&\A&\A\\
\B&\A&\A&\A\\
\A&\B&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}

and how to solve it:

\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\A&\A&\A&\A\\
\B&\B&\A&\A\\
\B&\A&\A&\A\\
\A&\B&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\A&\A&\A&\A\\
\B&\A&\A&\B\\
\B&\A&\A&\A\\
\A&\B&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\A&\A&\A\\
\B&\A&\A&\B\\
\A&\A&\A&\A\\
\A&\B&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\A&\A&\A\\
\A&\A&\B&\B\\
\A&\A&\A&\A\\
\A&\B&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\A&\A&\A\\
\A&\A&\B&\B\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\B&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\A&\A\\
\A&\A&\B&\B\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\B&\A\\
\A&\A&\A&\B\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}
\hspace{0.25ex}
\begin{tikzpicture}[every node/.style={anchor=base,text depth=.5ex,text height=2ex,text width=1em,outer sep=0pt,align=center,inner sep=0pt}] \matrix [matrix of nodes,draw=white,nodes in empty cells] {
\B&\B&\B&\B\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
\A&\A&\A&\A\\
};
\end{tikzpicture}


\begin{exercise}
Write a program that reads in a roller-board file (specified on the command line), and shows the `moves' to solve it. Such a file looks something like~:
\begin{terminaloutput}
5 4
0000
1100
1000
0100
0000
\end{terminaloutput}

\noindent The first line has two numbers; the height of
the board (number of rows) and then the width (number of columns).

\noindent
In the remainder of the file, the number of $1$s must be equal to the width of the board, and only the characters `0' and `1' are valid.You may assume that the maximum height and width of a board is $6$.

\noindent
The brute-force algorithm for searching over all moves for a
solution goes like this~:
\begin{enumerate}
\item You will use an \verb^alloc()^'d array (list) of boards.
\item Put the initial board into the front of this list, \verb^f=0^.
\item Consider the board at the {\bf front} of the list (index \verb$f$).
\item For this (parent) board, find the resulting (child) boards 
which can be created from all the possible $(rows + columns) \times 2$ rolls. For each of these child boards:
\begin{itemize}
\item If this board is unique (i.e.\ it has not been seen before in the list), add it to the end of the list.
\item If it has been seen before (a duplicate) ignore it.
\item If it is the `final' board, stop and print the solution.
\end{itemize}
\item Add one of $f$. If there are more boards in the list, go to step $3$.
\end{enumerate}

\noindent To help with printing out the correct moves, when a solution
has been found, each structure in the list will need to contain (amongst
other things) a board and a record of its parent board, i.e. the board
that it was created from. Since you're using an array, this could simply
be which element of the array was the parent.

\noindent The program reads the name of the board definition file from
the command line.  If it finds a successful solution, it prints out the
number of boards that would be printed in the solution and {\bf nothing
else}, or else exactly the phrase `No Solution?'' if none can be found
(as might be the case if you simply run out of memory)~:

\begin{terminaloutput}
$ ./rollerboard 4x4diag.rbd
4 moves
$ ./rollerboard 5x5lhs.rbd
8 moves
\end{terminaloutput}


If the `verbose' flag is used, your program will print out the solution in the correct order~:
\begin{terminaloutput}
$ ./rollerboard -v 4x4lr.rbd
0:
0000
1001
1001
0000

1:
1000
1001
0001
0000

2:
0100
1001
0001
0000

3:
1100
0001
0001
0000

4:
1101
0001
0000
0000

5:
1110
0001
0000
0000

6:
1111
0000
0000
0000 

$ ./rollerboard -v 3x3crn.rbd
0:
000
001
011

1:
000
100
011

2:
100
000
011

3:
110
000
001

4:
111
000
000

\end{terminaloutput}

\noindent
Your program~:
\begin{itemize}
\item {\bf Must} use the algorithm detailed above (which is similar to a queue and therefore a breadth-first search). Do not use the other algorithms possible (e.g. best-first, guided, recursive etc.); the quality of your coding is being assessed against others taking the same approach.
\item {\bf Must not} use dynamic arrays or linked lists. Since boards cannot be any larger than $6 \times 6$, you can create boards of this size, and only use a sub-part of them if the board required is smaller. The list of boards can be a fixed (large) size.
\item {\bf Should} check for invalid board definition files, and report in a graceful way if there is a problem, aborting with \verb^exit(EXIT_FAILURE)^ if so.
\item {\bf Should not} print anything else out to screen after successfully
completing the search, except that which is shown above. Automated checking
will be used during marking, and therefore the output must be precise.
\item {\bf Should} call the function \verb^test()^ to perform any assertion testing etc.
\end{itemize}


\subsection*{Extension}

Basic assignment = {\Large $90\%$}.
Extension = {\Large $10\%$}.

\noindent
If you'd like to try an extension, make sure to submit {\it extension.c}
and a brief description in a {\it extension.txt} file. This could
involve a faster search technique, better graphical display, user input
or something else of your choosing.

\end{exercise}
